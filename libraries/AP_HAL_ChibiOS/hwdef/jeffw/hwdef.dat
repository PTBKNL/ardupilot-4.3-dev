# hw definition file for processing by chibios_hwdef.py
# for FMUv3 hardware (ie. for Pixhawk1, Pixhawk2 cube, XUAV2.1 etc)

# This hwdef.dat file contains a lot of comments so it can act as a
# reference for developers adding new boards.

# The hwdef.dat file defines all the hardware peripherals and pins for
# a port of ArduPilot to a board using the ChibiOS HAL. You should be
# able to write the hwdef.dat file for a new board with just the
# schematic for the board.

# This file is processed by chibios_hwdef.py to create hwdef.h for
# this board. You may find it useful to run chibios_hwdef.py manually
# when building this file for a new board. The resulting hwdef.h file
# is formatted to make it quite readable. It is strongly suggested
# that you read the resulting hwdef.h file when porting to a new board
# to make sure it has resulted in what you want.

# You should read this file in conjunction with the schematic for your
# board, the datasheet for the MCU for your board and the python
# tables file that we have extracted from the datasheet for your
# MCU. The python tables file is particularly important, so if you
# haven't seen it before go and look at it now. For the STM32F427 it
# it called STM32F427xx.py and it is in the hwdef/script/ directory
# inside the HAL_ChibiOS directory. That file tells you what each pin
# can do (the alternate functions table) and what DMA channels can be
# used for each peripheral type. The alternative functions table is
# particularly useful when doing a new hwdef.dat file as you can work
# out peripheral numbers given a port/pin name.

# We need to start off by saying what main CPU is on the board. There
# are two CPU identifiers that you need to specify. The first is the
# ChibiOS MCU type. So far we only support STM32F4xx for all STM32F4
# board types. In the future we will add F7 and other MCU types
# The second string needs to match the name of a config file in the
# libraries/AP_HAL_ChibiOS/hwdef/script directory. In this case we are
# using a F427 MCU, so we select STM32F427xx to match the
# STM32F427xx.py file in the script directory. If you are supporting a
# board type that doesn't have a python hardware database file yet
# then you will need to create one. There are scripts in the scripts
# directory to help with that by parsing the STM32 datasheets to
# extract the required DMA and alternate function tables.

# MCU class and specific type
MCU STM32F4xx STM32F427xx

# We set a specific HAL_BOARD_SUBTYPE, allowing for custom config in
# drivers. For this to be used the subtype needs to be added to
# AP_HAL/AP_HAL_Boards.h as well.
define CONFIG_HAL_BOARD_SUBTYPE HAL_BOARD_SUBTYPE_CHIBIOS_FMUV3

# Now we need to specify the APJ_BOARD_ID. This is the ID that the
# bootloader presents to GCS software so it knows if this firmware is
# suitable for the board. Please see
# https://github.com/ArduPilot/Bootloader/blob/master/hw_config.h for
# a list of current board IDs. If you add a new board type then please
# get it added to that repository so we don't get conflicts.

# Note that APJ is "ArduPilot JSON Firmware Format".

# board ID for firmware load
APJ_BOARD_ID 9


# crystal frequency
OSCILLATOR_HZ 24000000

# ChibiOS system timer
STM32_ST_USE_TIMER 5

# flash size
FLASH_SIZE_KB 2048

define HAL_CHIBIOS_ARCH_FMUV3 1

# These are the pins for SWD debugging with a STlinkv2 or black-magic probe.
PA13 JTMS-SWDIO SWD
PA14 JTCK-SWCLK SWD

###################################

# USB
USB_STRING_MANUFACTURER "Wurzbach"
PA11 OTG_FS_DM OTG1
PA12 OTG_FS_DP OTG1
PA9 VBUS INPUT OPENDRAIN

############################

# CAN
PD0 CAN1_RX CAN1
PD1 CAN1_TX CAN1
PB6 CAN2_TX CAN2
PB12 CAN2_RX CAN2

define CAN_APP_NODE_NAME "org.ardupilot.jeffw"

############################

# I2C
I2C_ORDER I2C1 I2C2
PB8  I2C1_SCL I2C1
PB9  I2C1_SDA I2C1
PB10 I2C2_SCL I2C2
PB11 I2C2_SDA I2C2

############################

# Serial UARTs
SERIAL_ORDER OTG1 USART2 USART3 UART4 UART8 UART7 USART6

# UART 1
PD5 USART2_TX USART2
PD6 USART2_RX USART2

# UART 2
PD8 USART3_TX USART3
PD9 USART3_RX USART3

# UART 3
PA0 UART4_TX UART4
PA1 UART4_RX UART4

# UART 4
PE0 UART8_RX UART8
PE1 UART8_TX UART8

# UART 5 (STM32_SWD_DBG)
PF6 UART7_RX UART7
PF7 UART7_TX UART7

# UART 6 (RC_TRIG_IN)
PG9 USART6_RX USART6
PG14 USART6_TX USART6

############################

# SPI
PA5 SPI1_SCK SPI1
PA6 SPI1_MISO SPI1
PA7 SPI1_MOSI SPI1

############################

# microSD card
PC8 SDIO_D0 SDIO
PC9 SDIO_D1 SDIO
PC10 SDIO_D2 SDIO
PC11 SDIO_D3 SDIO
PC12 SDIO_CK SDIO
PD2 SDIO_CMD SDIO

define HAL_OS_FATFS_IO 1
define HAL_BOARD_LOG_DIRECTORY "/APM/LOGS"
define HAL_BOARD_TERRAIN_DIRECTORY "/APM/TERRAIN"

############################

# Param Storage
STORAGE_FLASH_PAGE 2
define HAL_STORAGE_SIZE 15360
FLASH_RESERVE_START_KB 64

############################

# ADCs
define HAL_USE_ADC FALSE
define STM32_ADC_USE_ADC1 FALSE
define HAL_DISABLE_ADC_DRIVER TRUE

############################

# PWMs
# CAM_TRIG_1 - CAM_TRIG_6
PE14 TIM1_CH4 TIM1 PWM(1) GPIO(50)
PE13 TIM1_CH3 TIM1 PWM(2) GPIO(51)
PE11 TIM1_CH2 TIM1 PWM(3) GPIO(52)
PE9  TIM1_CH1 TIM1 PWM(4) GPIO(53)
PD13 TIM4_CH2 TIM4 PWM(5) GPIO(54)
PD14 TIM4_CH3 TIM4 PWM(6) GPIO(55)

############################

# GPIOs

PE8 FMU_LED_AMBER OUTPUT HIGH GPIO(1)       # DEBUG1 LED1
PE10 LED_SAFETY OUTPUT GPIO(2)              # DEBUG2 LED2
PE12 DEBUG3 OUTPUT GPIO(3)                  # DEBUG3 LED3
PE15 DEBUG4 OUTPUT GPIO(4)                  # DEBUG4 LED4

PF11 PWR_MON_CRITICAL INPUT GPIO(10)
PF12 PWR_MON_WARN INPUT GPIO(11)
PF13 PWR_MON_TC INPUT GPIO(12)
PF14 PWR_MON_PV INPUT GPIO(13)

# RTC 32.768kHz crystal. Not supported
PC14 RTC_37KHZ_A INPUT GPIO(14)
PC15 RTC_37KHZ_B INPUT GPIO(15)

PA2 CAM_SHOE_1 OUTPUT GPIO(21)
PA3 CAM_SHOE_2 OUTPUT GPIO(22)
PA15 CAM_SHOE_3 OUTPUT GPIO(23)
PB3 CAM_SHOE_4 OUTPUT GPIO(24)
PB1 CAM_SHOE_5 OUTPUT GPIO(25)
PB0 CAM_SHOE_6 OUTPUT GPIO(26)

PH2 CAM_STROBE_1 OUTPUT GPIO(27)
PH3 CAM_STROBE_2 OUTPUT GPIO(28)
PH4 CAM_STROBE_3 OUTPUT GPIO(29)
PH5 CAM_STROBE_4 OUTPUT GPIO(30)
PH6 CAM_STROBE_5 OUTPUT GPIO(31)
PH7 CAM_STROBE_6 OUTPUT GPIO(32)

PH8 CAM_SHOE_EN_1 OUTPUT GPIO(33)
PH9 CAM_SHOE_EN_2 OUTPUT GPIO(34)
PH10 CAM_SHOE_EN_3 OUTPUT GPIO(35)
PH11 CAM_SHOE_EN_4 OUTPUT GPIO(36)
PH12 CAM_SHOE_EN_5 OUTPUT GPIO(37)
PH13 CAM_SHOE_EN_6 OUTPUT GPIO(38)

PF8 PWM_IN INPUT GPIO(42)               # TIM13_CH1 is not mapped correctly in the DMA matrix so we can't use it's timer :(
PF9 HOTSHOE_OUT OUTPUT GPIO(43)

PB2 TEST_POINT_85 INPUT GPIO(85)        # BOOT1
PD3 TEST_POINT_86 OUTPUT GPIO(86)
PD4 TEST_POINT_87 OUTPUT GPIO(87)
PD11 TEST_POINT_88 OUTPUT GPIO(88)
PD12 TEST_POINT_89 OUTPUT GPIO(89)
PE2 TEST_POINT_90 OUTPUT GPIO(90)
PE3 TEST_POINT_91 OUTPUT GPIO(91)
PE4 TEST_POINT_92 OUTPUT GPIO(92)
PE5 TEST_POINT_93 OUTPUT GPIO(93)
PE6 TEST_POINT_95 OUTPUT GPIO(95)
PE7 TEST_POINT_97 OUTPUT GPIO(97)

############################

# peripherals
PA4 BARO_CS1 CS          # SPI1_CS1
PA8 ICM20689_1_CS2 CS    # SPI1_CS2
PB4 ICM20689_2_CS3 CS    # SPI1_CS3

SPIDEV ms5611         SPI1 DEVID3  BARO_CS1      MODE3 20*MHZ 20*MHZ
SPIDEV icm20689_1     SPI1 DEVID1  ICM20689_1_CS2 MODE3  2*MHZ  8*MHZ
SPIDEV icm20689_2     SPI1 DEVID2  ICM20689_2_CS3 MODE3  2*MHZ  8*MHZ

BARO MS56XX SPI:ms5611
IMU Invensense SPI:icm20689_1 ROTATION_NONE
IMU Invensense SPI:icm20689_2 ROTATION_NONE

############################
